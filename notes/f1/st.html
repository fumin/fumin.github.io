<html>
<head>
  <meta charset="utf-8"/>
  <script src="https://unpkg.com/vtk.js"></script>
  <link rel="stylesheet" href="SceneExplorer.module.css">
</head>
<body>
  <script>
function filterPoly(poly, cutoff) {
  const polyData = vtk.Common.DataModel.vtkPolyData.newInstance();

  const points = new Float32Array(poly.getPoints().getNumberOfValues());
  points.set(poly.getPoints().getData());

  const polyLines = poly.getLines().getData();
  const pls = [];
  var lineLen = polyLines[0];
  var curLine = [];
  for (let i = 1; i < polyLines.length; i++) {
    if (curLine.length == lineLen) {
      pls.push(curLine);
      curLine = [];

      lineLen = polyLines[i];
      continue;
    }
    curLine.push(polyLines[i]);
  }
  pls.push(curLine);
  // Check that we extracted correctly.
  for (let i = 0; i < pls.length; i++) {
    if (pls[i].length != poly.getLines().getCellSizes()[i]) {
      alert();
    }
  }
  // Filter.
  const integrationTime = poly.getPointData().getArrayByName("IntegrationTime").getData();
  var filteredLines = [];
  for (let i = 0; i < pls.length; i++) {
    var filtered = [];
    for (let j = 0; j < pls[i].length; j++) {
      const igt = integrationTime[pls[i][j]];
      if (igt > cutoff) {
        break;
      }
      filtered.push(pls[i][j]);
    }
    filteredLines.push(filtered);
  }
  // Encode.
  var flattened = [];
  for (let i = 0; i < filteredLines.length; i++) {
    flattened.push(filteredLines[i].length);
    for (let j = 0; j < filteredLines[i].length; j++) {
      flattened.push(filteredLines[i][j]);
    }
  }
  const lines = new Int32Array(flattened);

  const uValues = new Float32Array(poly.getPointData().getArrayByName("U").getNumberOfValues());
  uValues.set(poly.getPointData().getArrayByName("U").getData());
  const u = vtk.Common.Core.vtkDataArray.newInstance({
    name: "U",
    numberOfComponents: 3,
    values: uValues,
  });

  polyData.getPoints().setData(points, 3);
  polyData.getLines().setData(lines, 1);
  polyData.getPointData().addArray(u);
  return polyData;
}

// Replaces HttpDataSetReader.
function newStreamSource(poly) {
  const source = vtk.macro.newInstance((publicAPI, model) => {
    vtk.macro.obj(publicAPI, model);
    vtk.macro.algo(publicAPI, model, 0, 1);
    model.poly = poly;
    publicAPI.requestData = (inData, outData) => {
      outData[0] = filterPoly(poly, 0.5);
    };
  })();
  return source
}

function editStream(sceneLoader) {
  // We pick the 0th scene as defined in our vtkjs file.
  const scene = sceneLoader.getScene()[0];
  // source is the vtkHttpDataSetReader.
  const source = scene.source;
  // Get the vtkPolyData that is being defined in the index.json of our vtkjs file.
  const poly = source.getOutputData();

  // Return if we haven't finished loaded yet.
  const numLines = poly.getLines().getNumberOfCells();
  if (numLines == 0) {
    return;
  }

  const streamSource = newStreamSource(poly);
  scene.mapper.setInputConnection(streamSource.getOutputPort());
  scene.mapper.modified();
}

function setDisplay(sceneLoader) {
  const cam = sceneLoader.getRenderer().getActiveCamera();
  cam.setParallelProjection(true);
  cam.setParallelScale(3);

  const streamTracerScene = sceneLoader.getScene()[0];
  // To fix stream lines too dark.
  streamTracerScene.actor.getProperty().setAmbient(1);
}

function load(container, options) {
  const fullScreenRenderer = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({
    background: [1, 1, 1],
    rootContainer: container,
    containerStyle: { height: '100%', width: '100%', position: 'absolute' },
  });
  const renderer = fullScreenRenderer.getRenderer();
  const renderWindow = fullScreenRenderer.getRenderWindow();

  function onReady(sceneLoader) {
    sceneLoader.onReady(() => {
      editStream(sceneLoader);
ggg = renderer;
ggw = renderWindow;
ggsi = sceneLoader;
      setDisplay(sceneLoader);
      renderWindow.render();
    });

    window.addEventListener('dblclick', () => {
      sceneLoader.resetScene();
      setDisplay(sceneLoader);
      renderWindow.render();
    });
  }

  const progressContainer = document.createElement('div');
  progressContainer.setAttribute('class', "progress");
  container.appendChild(progressContainer);

  const progressCallback = (progressEvent) => {
    if (progressEvent.lengthComputable) {
      const percent = Math.floor(
        (100 * progressEvent.loaded) / progressEvent.total
      );
      progressContainer.innerHTML = `Loading ${percent}%`;
    } else {
      progressContainer.innerHTML = vtk.macro.formatBytesToProperUnit(
        progressEvent.loaded
      );
    }
  };

  // HttpDataAccessHelper.
  vtk.IO.Core.DataAccessHelper.get("http").fetchBinary(options.fileURL, {
    progressCallback,
  }).then((zipContent) => {
    container.removeChild(progressContainer);
    const dataAccessHelper = vtk.IO.Core.DataAccessHelper.get('zip', {
      zipContent,
      callback: (zip) => {
        const sceneLoader = vtk.IO.Core.vtkHttpSceneLoader.newInstance({
          renderer,
          dataAccessHelper,
        });
        sceneLoader.setUrl('index.json');
        onReady(sceneLoader);
      },
    });
  });
}

function main() {
  const root = document.querySelector('body');
  root.classList.add("fullScreen");
  const options = {fileURL: "st.vtkjs"};
  load(root, options);
}
main();
  </script>
</body>
</html>
